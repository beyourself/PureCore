diff --git a/sql/arena-spectator/spectator.sql b/sql/arena-spectator/spectator.sql
new file mode 100644
index 0000000..39cff15
--- /dev/null
+++ b/sql/arena-spectator/spectator.sql
@@ -0,0 +1,12 @@
+-- Implement Arena Spectator
+DELETE FROM `command` WHERE `name` = 'spectate';
+INSERT INTO `command` (`name`, `security`, `help`) VALUES ('spectate', 0, 'Syntax: .spectate $subcommand.\nUse .help sppectate');
+DELETE FROM `command` WHERE `name` = 'spectate view';
+INSERT INTO `command` (`name`, `security`, `help`) VALUES ('spectate view', 0, 'Syntax: .spectate view #player\nAllow player to spectate arena from anotherplayer.');
+DELETE FROM `command` WHERE `name` = 'spectate leave';
+INSERT INTO `command` (`name`, `security`, `help`) VALUES ('spectate leave', 0, 'Syntax: .spectate leave\nDisable spectator mode.');
+DELETE FROM `command` WHERE `name` = 'spectate player';
+INSERT INTO `command` (`name`, `security`, `help`) VALUES ('spectate player', 0, 'Syntax: .spectate player #player\nAllow to spectate player.');
+DELETE FROM `command` WHERE `name` = 'spectate reset';
+INSERT INTO `command` (`name`, `security`, `help`) VALUES ('spectate reset', 0, 'Syntax: .spectate reset\nSend addon data.');
+UPDATE `gameobject_template` SET `flags` = 36 WHERE entry IN (185918, 185917, 183970, 183971, 183972, 183973, 183977, 183979, 183978, 183980, 192642, 192643);
\ No newline at end of file
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index e091df1..23a32d7 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -823,6 +823,12 @@ void Battleground::EndBattleground(uint32 winner)
                 UpdatePlayerScore(player, SCORE_BONUS_HONOR, GetBonusHonorFromKill(loser_kills));
         }
 
+        if (isArena())
+        {
+            player->SetGMVisible(true);
+            player->SetGameMaster(false);
+        }
+
         player->ResetAllPowers();
         player->CombatStopWithPets(true);
 
@@ -952,6 +958,8 @@ void Battleground::RemovePlayerAtLeave(ObjectGuid guid, bool Transport, bool Sen
         // reset destination bg team
         player->SetBGTeam(0);
 
+
+
         if (Transport)
             player->TeleportToBGEntryPoint();
 
@@ -1128,6 +1136,14 @@ void Battleground::EventPlayerLoggedOut(Player* player)
     // player is correct pointer, it is checked in WorldSession::LogoutPlayer()
     m_OfflineQueue.push_back(player->GetGUID());
     m_Players[guid].OfflineRemoveTime = sWorld->GetGameTime() + MAX_OFFLINE_TIME;
+
+    if (player->isSpectator())
+    {
+        player->TeleportToBGEntryPoint();
+        RemoveSpectator(player->GetGUID());
+        return;
+    }
+
     if (GetStatus() == STATUS_IN_PROGRESS)
     {
         // drop flag and handle other cleanups
@@ -1135,9 +1151,11 @@ void Battleground::EventPlayerLoggedOut(Player* player)
 
         // 1 player is logging out, if it is the last, then end arena!
         if (isArena())
-            if (GetAlivePlayersCountByTeam(player->GetBGTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetBGTeam())))
-                EndBattleground(GetOtherTeam(player->GetBGTeam()));
+            if (GetAlivePlayersCountByTeam(player->GetTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetTeam())))
+                EndBattleground(GetOtherTeam(player->GetTeam()));
     }
+
+    player->LeaveBattleground();
 }
 
 // This method should be called only once ... it adds pointer to queue
@@ -1832,6 +1850,15 @@ void Battleground::HandleAreaTrigger(Player* player, uint32 trigger)
                    trigger, player->GetMapId(), player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
 }
 
+void Battleground::SendSpectateAddonsMsg(SpectatorAddonMsg msg)
+{
+    if (!HaveSpectators())
+        return;
+
+    for (SpectatorList::iterator itr = m_Spectators.begin(); itr != m_Spectators.end(); ++itr)
+         msg.SendPacket(*itr);
+}
+
 bool Battleground::CheckAchievementCriteriaMeet(uint32 criteriaId, Player const* /*source*/, Unit const* /*target*/, uint32 /*miscvalue1*/)
 {
     TC_LOG_ERROR("bg.battleground", "Battleground::CheckAchievementCriteriaMeet: No implementation for criteria %u", criteriaId);
diff --git a/src/server/game/Battlegrounds/Battleground.h b/src/server/game/Battlegrounds/Battleground.h
index 562a20b..7fd9252 100644
--- a/src/server/game/Battlegrounds/Battleground.h
+++ b/src/server/game/Battlegrounds/Battleground.h
@@ -26,6 +26,8 @@
 #include "WorldPacket.h"
 #include "Object.h"
 #include "GameObject.h"
+#include "SpectatorAddon.h"
+#include <unordered_set>
 
 class Creature;
 class GameObject;
@@ -300,6 +302,12 @@ class Battleground
         bool HasFreeSlots() const;
         uint32 GetFreeSlotsForTeam(uint32 Team) const;
 
+        typedef std::unordered_set<ObjectGuid> SpectatorList;
+        void AddSpectator(ObjectGuid playerId) { m_Spectators.insert(playerId); }
+        void RemoveSpectator(ObjectGuid playerId) { m_Spectators.erase(playerId); }
+        bool HaveSpectators() { return (m_Spectators.size() > 0); }
+        void SendSpectateAddonsMsg(SpectatorAddonMsg msg);
+
         bool isArena() const        { return m_IsArena; }
         bool isBattleground() const { return !m_IsArena; }
         bool isRated() const        { return m_IsRated; }
@@ -577,6 +585,7 @@ class Battleground
         // Raid Group
         Group* m_BgRaids[BG_TEAMS_COUNT];                   // 0 - alliance, 1 - horde
 
+        SpectatorList m_Spectators;
         // Players count by team
         uint32 m_PlayersCount[BG_TEAMS_COUNT];
 
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.h b/src/server/game/Battlegrounds/BattlegroundMgr.h
index f732f43..707102e 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.h
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.h
@@ -85,6 +85,7 @@ class BattlegroundMgr
         Battleground* GetBattleground(uint32 InstanceID, BattlegroundTypeId bgTypeId);
         Battleground* GetBattlegroundTemplate(BattlegroundTypeId bgTypeId);
         Battleground* CreateNewBattleground(BattlegroundTypeId bgTypeId, PvPDifficultyEntry const* bracketEntry, uint8 arenaType, bool isRated);
+        BattlegroundContainer GetBattlegroundsByType(BattlegroundTypeId bgTypeId) { return m_Battlegrounds[bgTypeId]; }
 
         void AddBattleground(Battleground* bg);
         void RemoveBattleground(BattlegroundTypeId bgTypeId, uint32 instanceId);
@@ -109,6 +110,7 @@ class BattlegroundMgr
 
         bool isArenaTesting() const { return m_ArenaTesting; }
         bool isTesting() const { return m_Testing; }
+        bool IsArenaType(BattlegroundTypeId bgTypeId);
 
         static BattlegroundQueueTypeId BGQueueTypeId(BattlegroundTypeId bgTypeId, uint8 arenaType);
         static BattlegroundTypeId BGTemplateId(BattlegroundQueueTypeId bgQueueTypeId);
@@ -134,11 +136,12 @@ class BattlegroundMgr
     private:
         bool CreateBattleground(BattlegroundTemplate const* bgTemplate);
         uint32 CreateClientVisibleInstanceId(BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id);
-        static bool IsArenaType(BattlegroundTypeId bgTypeId);
+        // static bool IsArenaType(BattlegroundTypeId bgTypeId);
         BattlegroundTypeId GetRandomBG(BattlegroundTypeId id);
 
         typedef std::map<BattlegroundTypeId, BattlegroundData> BattlegroundDataContainer;
         BattlegroundDataContainer bgDataStore;
+        BattlegroundContainer m_Battlegrounds[MAX_BATTLEGROUND_TYPE_ID];
 
         BattlegroundQueue m_BattlegroundQueues[MAX_BATTLEGROUND_QUEUE_TYPES];
 
diff --git a/src/server/game/Battlegrounds/SpectatorAddon.cpp b/src/server/game/Battlegrounds/SpectatorAddon.cpp
new file mode 100644
index 0000000..e22faa4
--- /dev/null
+++ b/src/server/game/Battlegrounds/SpectatorAddon.cpp
@@ -0,0 +1,201 @@
+#include "ScriptPCH.h"
+
+SpectatorAddonMsg::SpectatorAddonMsg()
+{
+    for (uint8 i = 0; i < SPECTATOR_PREFIX_COUNT; ++i)
+        prefixFlags[i] = false;
+
+    player = "";
+    target = "";
+    isAlive = false;
+    pClass = CLASS_WARRIOR;
+    maxHP = 0;
+    maxPower = 0;
+    currHP = 0;
+    currPower = 0;
+    powerType = POWER_MANA;
+    spellId = 0;
+    castTime = 0;
+    team = ALLIANCE;
+}
+
+bool SpectatorAddonMsg::CanSandAura(uint32 auraID)
+{
+    const SpellInfo *spell = sSpellMgr->GetSpellInfo(auraID);
+
+    if (!spell)
+        return false;
+
+    if (spell->SpellIconID == 1)
+        return false;
+
+    return true;
+}
+
+void SpectatorAddonMsg::CreateAura(ObjectGuid _caster, uint32 _spellId, bool _isDebuff, uint8 _type, int32 _duration, int32 _expire, uint16 _stack, bool _isRemove)
+{
+    if (!CanSandAura(_spellId))
+        return;
+
+    aCaster = _caster;
+    aSpellId = _spellId;
+    aIsDebuff = _isDebuff;
+    aType = _type;
+    aDuration = _duration;
+    aExpire = _expire;
+    aStack = _stack;
+    aRemove = _isRemove;
+    EnableFlag(SPECTATOR_PREFIX_AURA);
+}
+
+std::string SpectatorAddonMsg::GetMsgData()
+{
+    std::string addonData = "";
+
+    if (!isFilledIn(SPECTATOR_PREFIX_PLAYER))
+    {
+        TC_LOG_INFO("bg.battleground", "SPECTATOR ADDON: player is not filled in.");
+        return addonData;
+    }
+
+    std::string msg = "";
+    for (uint8 i = 0; i < SPECTATOR_PREFIX_COUNT; ++i)
+        if (isFilledIn(i))
+        {
+            switch (i)
+            {
+                case SPECTATOR_PREFIX_PLAYER:
+                    msg += player + ";";
+                    break;
+                case SPECTATOR_PREFIX_TARGET:
+                    msg += "TRG=" + target + ";";
+                    break;
+                case SPECTATOR_PREFIX_TEAM:
+                {
+                    char buffer[20];
+                    sprintf(buffer, "TEM=%i;", (uint16)team);
+                    msg += buffer;
+                    break;
+                }
+                case SPECTATOR_PREFIX_STATUS:
+                {
+                    char buffer[20];
+                    sprintf(buffer, "STA=%d;", isAlive);
+                    msg += buffer;
+                    break;
+                }
+                case SPECTATOR_PREFIX_CLASS:
+                {
+                    char buffer[20];
+                    sprintf(buffer, "CLA=%i;", (int)pClass);
+                    msg += buffer;
+                    break;
+                }
+                case SPECTATOR_PREFIX_MAXHP:
+                {
+                    char buffer[30];
+                    sprintf(buffer, "MHP=%i;", maxHP);
+                    msg += buffer;
+                    break;
+                }
+                case SPECTATOR_PREFIX_CURHP:
+                {
+                    char buffer[30];
+                    sprintf(buffer, "CHP=%i;", currHP);
+                    msg += buffer;
+                    break;
+                }
+                case SPECTATOR_PREFIX_MAXPOWER:
+                {
+                    char buffer[30];
+                    sprintf(buffer, "MPW=%i;", maxPower);
+                    msg += buffer;
+                    break;
+                }
+                case SPECTATOR_PREFIX_CURPOWER:
+                {
+                    char buffer[30];
+                    sprintf(buffer, "CPW=%i;", currPower);
+                    msg += buffer;
+                    break;
+                }
+                case SPECTATOR_PREFIX_POWERTYPE:
+                {
+                    char buffer[20];
+                    sprintf(buffer, "PWT=%i;", (uint8)powerType);
+                    msg += buffer;
+                    break;
+                }
+                case SPECTATOR_PREFIX_SPELL:
+                {
+                    char buffer[80];
+                    sprintf(buffer, "SPE=%i,%i;", spellId, castTime);
+                    msg += buffer;
+                    break;
+                }
+                case SPECTATOR_PREFIX_AURA:
+                {
+                    char buffer[300];
+                    sprintf(buffer, "AUR=%i,%i,%i,%i,%i,%i,%i,0x%X;", aRemove, aStack,
+                        aExpire, aDuration,
+                        aSpellId, aType,
+                        aIsDebuff, aCaster);
+                    msg += buffer;
+                    break;
+                }
+            }
+        }
+
+    if (msg != "")
+        addonData = "ARENASPEC	" + msg;
+
+    return addonData;
+}
+
+bool SpectatorAddonMsg::SendPacket(ObjectGuid receiver)
+{
+    std::string addonData = GetMsgData();
+    if (addonData == "")
+        return false;
+
+    Player* rPlayer = ObjectAccessor::FindPlayer(receiver);
+    if (!rPlayer)
+        return false;
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    data << uint8(CHAT_MSG_WHISPER);
+    data << uint32(LANG_ADDON);
+    data << uint64(0);
+    data << uint32(LANG_ADDON);                               //language 2.1.0 ?
+    data << uint64(0);
+    data << uint32(addonData.length() + 1);
+    data << addonData;
+    data << uint8(CHAT_TAG_NONE);
+    rPlayer->GetSession()->SendPacket(&data);
+
+    return true;
+}
+
+bool SpectatorAddonMsg::SendPacket(SpectatorAddonMsg msg, ObjectGuid receiver)
+{
+    std::string addonData = msg.GetMsgData();
+    if (addonData == "")
+        return false;
+
+    Player* rPlayer = ObjectAccessor::FindPlayer(receiver);
+    if (!rPlayer)
+        return false;
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    data << uint8(CHAT_MSG_WHISPER);
+    data << uint32(LANG_ADDON);
+    data << uint64(0);
+    data << uint32(LANG_ADDON);                               //language 2.1.0 ?
+    data << uint64(0);
+    data << uint32(addonData.length() + 1);
+    data << addonData;
+    data << uint8(CHAT_TAG_NONE);
+    rPlayer->GetSession()->SendPacket(&data);
+
+    return true;
+}
\ No newline at end of file
diff --git a/src/server/game/Battlegrounds/SpectatorAddon.h b/src/server/game/Battlegrounds/SpectatorAddon.h
new file mode 100644
index 0000000..cc3edd2
--- /dev/null
+++ b/src/server/game/Battlegrounds/SpectatorAddon.h
@@ -0,0 +1,77 @@
+#define SPECTATOR_ADDON_SPELL_INTERUPTED 99999 // specific addons
+#define SPECTATOR_ADDON_SPELL_CANCELED 99998   // numbers =\
+
+enum SpectatorPrefix {
+    SPECTATOR_PREFIX_PLAYER,
+    SPECTATOR_PREFIX_STATUS,
+    SPECTATOR_PREFIX_MAXHP,
+    SPECTATOR_PREFIX_CURHP,
+    SPECTATOR_PREFIX_MAXPOWER,
+    SPECTATOR_PREFIX_CURPOWER,
+    SPECTATOR_PREFIX_POWERTYPE,
+    SPECTATOR_PREFIX_TARGET,
+    SPECTATOR_PREFIX_CLASS,
+    SPECTATOR_PREFIX_TEAM,
+    SPECTATOR_PREFIX_SPELL,
+    SPECTATOR_PREFIX_AURA,
+    SPECTATOR_PREFIX_COUNT      // must be at the end of list
+};
+
+class SpectatorAddonMsg {
+    public:
+        SpectatorAddonMsg();
+
+        void SetPlayer(std::string _player)     { player    = _player;  EnableFlag(SPECTATOR_PREFIX_PLAYER); }
+        void SetStatus(bool _isAlive)           { isAlive   = _isAlive; EnableFlag(SPECTATOR_PREFIX_STATUS); }
+        void SetClass(uint8 _class)             { pClass    = _class;   EnableFlag(SPECTATOR_PREFIX_CLASS); }
+        void SetTarget(std::string _target)     { target    = _target;  EnableFlag(SPECTATOR_PREFIX_TARGET); }
+        void SetTeam(uint32 _team)              { team      = _team;    EnableFlag(SPECTATOR_PREFIX_TEAM); }
+
+        void SetMaxHP(uint16 hp)                { maxHP     = hp; EnableFlag(SPECTATOR_PREFIX_MAXHP); }
+        void SetCurrentHP(uint16 hp)            { currHP    = hp; EnableFlag(SPECTATOR_PREFIX_CURHP);  }
+        void SetMaxPower(uint16 power)          { maxPower  = power; EnableFlag(SPECTATOR_PREFIX_MAXPOWER); }
+        void SetCurrentPower(uint16 power)      { currPower = power; EnableFlag(SPECTATOR_PREFIX_CURPOWER); }
+        void SetPowerType(Powers power)         { powerType = power; EnableFlag(SPECTATOR_PREFIX_POWERTYPE); }
+
+        void CastSpell(uint32 _spellId, uint32 _castTime) { spellId = _spellId; castTime = _castTime; EnableFlag(SPECTATOR_PREFIX_SPELL); }
+        void CreateAura(ObjectGuid _caster,  uint32 _spellId, bool _isDebuff, uint8 _type, int32 _duration, int32 _expire, uint16 _stack, bool _isRemove);
+
+        static bool SendPacket(SpectatorAddonMsg msg, ObjectGuid receiver);
+        bool SendPacket(ObjectGuid receiver);
+
+        std::string GetMsgData();
+
+        bool isFilledIn(uint8 prefix) { return prefixFlags[prefix]; }
+
+        static bool CanSandAura(uint32 auraID);
+    private:
+
+        void EnableFlag(uint8 prefix) { prefixFlags[prefix] = true; }
+        std::string player;
+        bool isAlive;
+        std::string target;
+        uint8 pClass;
+
+        uint16 maxHP;
+        uint16 maxPower;
+        uint16 currHP;
+        uint16 currPower;
+        Powers powerType;
+
+        uint32 spellId;
+        uint32 castTime;
+
+        uint32 team;
+
+        // aura data
+        ObjectGuid aCaster;
+        uint32 aSpellId;
+        bool aIsDebuff;
+        uint8 aType;
+        int32 aDuration;
+        int32 aExpire;
+        uint16 aStack;
+        bool aRemove;
+
+        bool prefixFlags[SPECTATOR_PREFIX_COUNT];
+};
diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
index 6ca5ab4..2942141 100644
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -550,6 +550,10 @@ void GameObject::Update(uint32 diff)
                     }
                     else if (Unit* target = ObjectAccessor::GetUnit(*this, m_lootStateUnitGUID))
                     {
+                        if (Player *tmpPlayer = target->ToPlayer())
+                            if (tmpPlayer->isSpectator())
+                                return;
+
                         // Some traps do not have a spell but should be triggered
                         if (goInfo->trap.spellId)
                             CastSpell(target, goInfo->trap.spellId);
@@ -1751,6 +1755,11 @@ void GameObject::Use(Unit* user)
 
 void GameObject::CastSpell(Unit* target, uint32 spellId, bool triggered /*= true*/)
 {
+    if (target)
+        if (Player *tmpPlayer = target->ToPlayer())
+            if (tmpPlayer->isSpectator())
+                return;
+
     SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
     if (!spellInfo)
         return;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 87cff6f..531739e 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -1937,6 +1937,20 @@ void Player::setDeathState(DeathState s)
         SetUInt32Value(PLAYER_SELF_RES_SPELL, 0);
 }
 
+void Player::SetSelection(ObjectGuid guid)
+{
+    SetGuidValue(UNIT_FIELD_TARGET, guid);
+
+    if (Player *target = ObjectAccessor::FindPlayer(guid))
+        if (HaveSpectators())
+        {
+            SpectatorAddonMsg msg;
+            msg.SetPlayer(GetName());
+            msg.SetTarget(target->GetName());
+            SendSpectatorAddonMsgToBG(msg);
+        }
+}
+
 void Player::InnEnter(time_t time, uint32 mapid, float x, float y, float z)
 {
     inn_pos_mapid = mapid;
@@ -2375,7 +2389,18 @@ bool Player::TeleportToBGEntryPoint()
     ScheduleDelayedOperation(DELAYED_BG_MOUNT_RESTORE);
     ScheduleDelayedOperation(DELAYED_BG_TAXI_RESTORE);
     ScheduleDelayedOperation(DELAYED_BG_GROUP_RESTORE);
-    return TeleportTo(m_bgData.joinPos);
+
+    Battleground *oldBg = GetBattleground();
+    bool result = TeleportTo(m_bgData.joinPos);
+
+    if (isSpectator() && result)
+    {
+        SetSpectate(false);
+        if (oldBg)
+            oldBg->RemoveSpectator(GetGUID());
+    }
+
+    return result;
 }
 
 void Player::ProcessDelayedOperations()
@@ -2817,6 +2842,99 @@ void Player::SetInWater(bool apply)
     getHostileRefManager().updateThreatTables();
 }
 
+void Player::SetSpectate(bool on)
+{
+    if (on)
+    {
+        SetSpeed(MOVE_RUN, 3.0);
+        spectatorFlag = true;
+
+        m_ExtraFlags |= PLAYER_EXTRA_GM_ON;
+        setFaction(35);
+        SetGMVisible(false);
+        SetGameMaster(true);
+
+        if (Pet* pet = GetPet())
+            RemovePet(pet, PET_SAVE_NOT_IN_SLOT, true);
+
+        UnsummonPetTemporaryIfAny();
+
+        RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+        ResetContestedPvP();
+
+        getHostileRefManager().setOnlineOfflineState(false);
+        CombatStopWithPets();
+        /* comment here to remove morphs */
+        uint32 morphs[8] = { 25900, 18718, 29348, 22235, 30414, 736, 20582, 28213 };
+        SetDisplayId(morphs[urand(0, 7)]);
+        /* comment here to remove morphs */
+        SetDisplayId(20582);
+
+        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_ADMINISTRATOR);
+    }
+    else
+    {
+        uint32 newPhase = 0;
+        AuraEffectList const& phases = GetAuraEffectsByType(SPELL_AURA_PHASE);
+        if (!phases.empty())
+            for (AuraEffectList::const_iterator itr = phases.begin(); itr != phases.end(); ++itr)
+                newPhase |= (*itr)->GetMiscValue();
+
+        if (!newPhase)
+            newPhase = PHASEMASK_NORMAL;
+
+        SetPhaseMask(newPhase, false);
+
+        m_ExtraFlags &= ~PLAYER_EXTRA_GM_ON;
+        setFactionForRace(getRace());
+        RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_GM);
+        RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);
+        SetGMVisible(true);
+        SetGameMaster(false);
+
+        if (spectateFrom)
+            SetViewpoint(spectateFrom, false);
+
+        // restore FFA PvP Server state
+        if (sWorld->IsFFAPvPRealm())
+            SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+
+        // restore FFA PvP area state, remove not allowed for GM mounts
+        UpdateArea(m_areaUpdateId);
+        getHostileRefManager().setOnlineOfflineState(true);
+        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
+        spectateCanceled = false;
+        spectatorFlag = false;
+        RestoreDisplayId();
+        UpdateSpeed(MOVE_RUN, true);
+    }
+    UpdateObjectVisibility();
+}
+
+bool Player::HaveSpectators()
+{
+    if (isSpectator())
+        return false;
+
+    if (Battleground *bg = GetBattleground())
+        if (bg->isArena())
+        {
+            if (bg->GetStatus() != STATUS_IN_PROGRESS)
+                return false;
+
+            return bg->HaveSpectators();
+        }
+    return false;
+}
+
+void Player::SendSpectatorAddonMsgToBG(SpectatorAddonMsg msg)
+{
+    if (!HaveSpectators())
+        return;
+
+    GetBattleground()->SendSpectateAddonsMsg(msg);
+}
+
 void Player::SetGameMaster(bool on)
 {
     if (on)
@@ -18660,6 +18778,10 @@ void Player::_LoadSeasonalQuestStatus(PreparedQueryResult result)
     }
 
     m_SeasonalQuestChanged = false;
+
+    spectatorFlag = false;
+    spectateCanceled = false;
+    spectateFrom = NULL;
 }
 
 void Player::_LoadMonthlyQuestStatus(PreparedQueryResult result)
@@ -22555,6 +22677,9 @@ bool Player::IsVisibleGloballyFor(Player const* u) const
     if (!AccountMgr::IsPlayerAccount(u->GetSession()->GetSecurity()))
         return GetSession()->GetSecurity() <= u->GetSession()->GetSecurity();
 
+    if (isSpectator())
+        return false;
+
     // non faction visibility non-breakable for non-GMs
     return false;
 }
@@ -23404,6 +23529,31 @@ void Player::SendAurasForTarget(Unit* target)
         auraApp->BuildUpdatePacket(data, false);
     }
 
+    if (Player *stream = target->ToPlayer())
+    {
+        if (stream->HaveSpectators() && isSpectator())
+        {
+            for (Unit::VisibleAuraMap::const_iterator itr = visibleAuras->begin(); itr != visibleAuras->end(); ++itr)
+            {
+                AuraApplication * auraApp = itr->second;
+                auraApp->BuildUpdatePacket(data, false);
+                if (Aura* aura = auraApp->GetBase())
+                {
+                    SpectatorAddonMsg msg;
+                    ObjectGuid casterID;
+                    if (aura->GetCaster() && aura->GetCaster()->ToPlayer())
+                        casterID = aura->GetCaster()->GetGUID();
+                    msg.SetPlayer(stream->GetName());
+                    msg.CreateAura(casterID, aura->GetSpellInfo()->Id,
+                        aura->GetSpellInfo()->IsPositive(), aura->GetSpellInfo()->Dispel,
+                        aura->GetDuration(), aura->GetMaxDuration(),
+                        aura->GetStackAmount(), false);
+                    msg.SendPacket(GetGUID());
+                }
+            }
+        }
+    }
+
     GetSession()->SendPacket(&data);
 }
 
@@ -24540,8 +24690,18 @@ void Player::SetViewpoint(WorldObject* target, bool apply)
 {
     if (apply)
     {
+        if (target->ToPlayer() == this)
+            return;
+
         TC_LOG_DEBUG("maps", "Player::CreateViewpoint: Player %s create seer %u (TypeId: %u).", GetName().c_str(), target->GetEntry(), target->GetTypeId());
 
+        // remove Viewpoint if already have
+        if (isSpectator() && spectateFrom)
+        {
+            SetViewpoint(spectateFrom, false);
+            spectateFrom = NULL;
+        }
+
         if (!AddGuidValue(PLAYER_FARSIGHT, target->GetGUID()))
         {
             TC_LOG_FATAL("entities.player", "Player::CreateViewpoint: Player %s cannot add new viewpoint!", GetName().c_str());
@@ -24552,10 +24712,18 @@ void Player::SetViewpoint(WorldObject* target, bool apply)
         UpdateVisibilityOf(target);
 
         if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
-            ((Unit*)target)->AddPlayerToVision(this);
+        {
+            if (isSpectator())
+                spectateFrom = target->ToUnit();
+
+            target->ToUnit()->AddPlayerToVision(this);
+        }
     }
     else
     {
+        if (isSpectator() && !spectateFrom)
+            return;
+
         TC_LOG_DEBUG("maps", "Player::CreateViewpoint: Player %s remove seer", GetName().c_str());
 
         if (!RemoveGuidValue(PLAYER_FARSIGHT, target->GetGUID()))
@@ -24567,6 +24735,9 @@ void Player::SetViewpoint(WorldObject* target, bool apply)
         if (target->isType(TYPEMASK_UNIT) && !GetVehicle())
             ((Unit*)target)->RemovePlayerFromVision(this);
 
+        if (isSpectator())
+            spectateFrom = NULL;
+
         //must immediately set seer back otherwise may crash
         m_seer = this;
 
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 6114119..39d76c8 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -28,6 +28,7 @@
 #include "QuestDef.h"
 #include "SpellMgr.h"
 #include "Unit.h"
+#include "Battleground.h"
 
 #include <limits>
 #include <string>
@@ -1174,6 +1175,14 @@ class Player : public Unit, public GridObject<Player>
         void SetHas310Flyer(bool on) { if (on) m_ExtraFlags |= PLAYER_EXTRA_HAS_310_FLYER; else m_ExtraFlags &= ~PLAYER_EXTRA_HAS_310_FLYER; }
         void SetPvPDeath(bool on) { if (on) m_ExtraFlags |= PLAYER_EXTRA_PVP_DEATH; else m_ExtraFlags &= ~PLAYER_EXTRA_PVP_DEATH; }
 
+        bool HaveSpectators();
+        void SendSpectatorAddonMsgToBG(SpectatorAddonMsg msg);
+        bool isSpectateCanceled() { return spectateCanceled; }
+        void CancelSpectate() { spectateCanceled = true; }
+        Unit* getSpectateFrom() { return spectateFrom; }
+        bool isSpectator() const { return spectatorFlag; }
+        void SetSpectate(bool on);
+
         void GiveXP(uint32 xp, Unit* victim, float group_rate=1.0f);
         void GiveLevel(uint8 level);
 
@@ -1546,7 +1555,8 @@ class Player : public Unit, public GridObject<Player>
         Player* GetSelectedPlayer() const;
 
         void SetTarget(ObjectGuid /*guid*/) override { } /// Used for serverside target changes, does not apply to players
-        void SetSelection(ObjectGuid guid) { SetGuidValue(UNIT_FIELD_TARGET, guid); }
+        // void SetSelection(ObjectGuid guid) { SetGuidValue(UNIT_FIELD_TARGET, guid); }
+        void SetSelection(ObjectGuid guid);
 
         uint8 GetComboPoints() const { return m_comboPoints; }
         ObjectGuid GetComboTarget() const { return m_comboTarget; }
@@ -2674,6 +2684,10 @@ class Player : public Unit, public GridObject<Player>
         uint32 _pendingBindId;
         uint32 _pendingBindTimer;
 
+        bool spectatorFlag;
+        bool spectateCanceled;
+        Unit *spectateFrom;
+
         uint32 _activeCheats;
 };
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index fdd9136..9acc0e2 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -287,6 +287,21 @@ Unit::~Unit()
             m_currentSpells[i] = NULL;
         }
 
+    // remove viewpoint for spectator
+    if (!m_sharedVision.empty())
+    {
+        for (SharedVisionList::iterator itr = m_sharedVision.begin(); itr != m_sharedVision.end(); ++itr)
+        {
+            if ((*itr)->isSpectator() && (*itr)->getSpectateFrom())
+            {
+                (*itr)->SetViewpoint((*itr)->getSpectateFrom(), false);
+                if (m_sharedVision.empty())
+                    break;
+                --itr;
+            }
+        }
+    }
+
     _DeleteRemovedAuras();
 
     delete i_motionMaster;
@@ -13386,6 +13401,13 @@ void Unit::SetHealth(uint32 val)
     // group update
     if (Player* player = ToPlayer())
     {
+        if (player->HaveSpectators())
+        {
+            SpectatorAddonMsg msg;
+            msg.SetPlayer(player->GetName());
+            msg.SetCurrentHP(val);
+            player->SendSpectatorAddonMsgToBG(msg);
+        }
         if (player->GetGroup())
             player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_HP);
     }
@@ -13411,6 +13433,13 @@ void Unit::SetMaxHealth(uint32 val)
     // group update
     if (GetTypeId() == TYPEID_PLAYER)
     {
+        if (ToPlayer()->HaveSpectators())
+        {
+            SpectatorAddonMsg msg;
+            msg.SetPlayer(ToPlayer()->GetName());
+            msg.SetMaxHP(val);
+            ToPlayer()->SendSpectatorAddonMsgToBG(msg);
+        }
         if (ToPlayer()->GetGroup())
             ToPlayer()->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_MAX_HP);
     }
@@ -13448,6 +13477,14 @@ void Unit::SetPower(Powers power, uint32 val)
     // group update
     if (Player* player = ToPlayer())
     {
+        if (player->HaveSpectators())
+        {
+            SpectatorAddonMsg msg;
+            msg.SetPlayer(player->GetName());
+            msg.SetCurrentPower(val);
+            msg.SetPowerType(power);
+            player->SendSpectatorAddonMsgToBG(msg);
+        }
         if (player->GetGroup())
             player->SetGroupUpdateFlag(GROUP_UPDATE_FLAG_CUR_POWER);
     }
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 94f458e..2e50ed3 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -3257,6 +3257,12 @@ bool BattlegroundMap::AddPlayerToMap(Player* player)
 
 void BattlegroundMap::RemovePlayerFromMap(Player* player, bool remove)
 {
+    if (player && player->isSpectator() && !player->isSpectateCanceled())
+    {
+        if (GetBG())
+            GetBG()->RemoveSpectator(player->GetGUID());
+        player->SetSpectate(false);
+    }
     TC_LOG_INFO("maps", "MAP: Removing player '%s' from bg '%u' of map '%s' before relocating to another map", player->GetName().c_str(), GetInstanceId(), GetMapName());
     Map::RemovePlayerFromMap(player, remove);
 }
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 7b4e272..b185c56 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1414,6 +1414,7 @@ void AddBattlegroundScripts()
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
 
+void AddSC_arena_spectator_script();
 #endif
 
 void AddCustomScripts()
@@ -1421,5 +1422,6 @@ void AddCustomScripts()
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
 
+AddSC_arena_spectator_script();
 #endif
 }
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index 8f8295d..606c61a 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -2941,6 +2941,16 @@ void Spell::prepare(SpellCastTargets const* targets, AuraEffect const* triggered
 
     TC_LOG_DEBUG("spells", "Spell::prepare: spell id %u source %u caster %d customCastFlags %u mask %u", m_spellInfo->Id, m_caster->GetEntry(), m_originalCaster ? m_originalCaster->GetEntry() : -1, _triggeredCastFlags, m_targets.GetTargetMask());
 
+    if (GetCaster() && GetSpellInfo())
+        if (Player *tmpPlayer = GetCaster()->ToPlayer())
+            if (tmpPlayer->HaveSpectators())
+            {
+                SpectatorAddonMsg msg;
+                msg.SetPlayer(tmpPlayer->GetName());
+                msg.CastSpell(GetSpellInfo()->Id, GetSpellInfo()->CastTimeEntry->CastTime);
+                tmpPlayer->SendSpectatorAddonMsgToBG(msg);
+            }
+
     //Containers for channeled spells have to be set
     /// @todoApply this to all cast spells if needed
     // Why check duration? 29350: channelled triggers channelled
@@ -4684,6 +4694,10 @@ SpellCastResult Spell::CheckCast(bool strict)
             return SPELL_FAILED_ONLY_INDOORS;
     }
 
+    if (Player *tmpPlayer = m_caster->ToPlayer())
+        if (tmpPlayer->isSpectator())
+            return SPELL_FAILED_SPELL_UNAVAILABLE;
+
     // only check at first call, Stealth auras are already removed at second call
     // for now, ignore triggered spells
     if (strict && !(_triggeredCastFlags & TRIGGERED_IGNORE_SHAPESHIFT))
diff --git a/src/server/scripts/Custom/ArenaSpectator.cpp b/src/server/scripts/Custom/ArenaSpectator.cpp
new file mode 100644
index 0000000..43ae032
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaSpectator.cpp
@@ -0,0 +1,724 @@
+#include "ScriptPCH.h"
+#include "Chat.h"
+#include "ArenaTeamMgr.h"
+#include "BattlegroundMgr.h"
+#include "WorldSession.h"
+#include "Player.h"
+#include "ArenaTeam.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "CreatureTextMgr.h"
+#include "Config.h"
+
+enum NpcSpectatorAtions
+{
+    GOSSIP_ACTION_SHOW_MENU = 100,
+    // GOSSIP_ACTION + ArenaTeamType
+    GOSSIP_ACTION_SHOW_GAMES_PAGE = 500,
+    GOSSIP_ACTION_SHOW_GAMES = 1000,
+    GOSSIP_ACTION_TOP = 2000,
+    // GOSSIP_ACTION + ArenaTeamType, sender = teamId
+    GOSSIP_ACTION_DETAIL_ON_TEAM = 3000,
+    // GOSSIP_ACTION + ArenaTeamType, sender = playerGuid
+    GOSSIP_ACTION_DETAIL_ON_GAME = 4000,
+    // GOSSIP_ACTION + playerGuid
+    GOSSIP_ACTION_SPECTATE = 5000,
+};
+
+#define MAX_PER_PAGE 15
+#define MAX_TOP 15
+
+bool m_usingGossip;
+
+class arena_spectator_commands : public CommandScript
+{
+public:
+    arena_spectator_commands() : CommandScript("arena_spectator_commands") { }
+
+    static bool HandleSpectateCommand(ChatHandler* handler, char const* args)
+    {
+        if (!handler)
+            return false;
+        Player* player = handler->GetSession()->GetPlayer();
+
+        if (!player)
+            return false;
+
+        if (player->IsInCombat())
+        {
+            handler->PSendSysMessage("You are in Combat.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* target;
+        ObjectGuid target_guid;
+        std::string target_name;
+        if (!handler->extractPlayerTarget((char*)args, &target, &target_guid, &target_name))
+            return false;
+
+        if (target == player || target_guid == player->GetGUID())
+        {
+            handler->PSendSysMessage("Can't Spectate yourself.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!target)
+        {
+            handler->PSendSysMessage("Target not found.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Map* cMap = target->GetMap();
+        if (!cMap->IsBattleArena())
+        {
+            handler->PSendSysMessage("Player not in an arena.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (player->GetPet()) // TODO : Auto remove pet instead
+        {
+            handler->PSendSysMessage("You must recall your pet.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if ((player->GetMap()->IsBattlegroundOrArena() && !player->isSpectator()) || player->GetMap()->IsBattleground())
+        {
+            handler->PSendSysMessage("Not here.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        // all's well, set bg id
+        // when porting out from the bg, it will be reset to 0
+        player->SetBattlegroundId(target->GetBattlegroundId(), target->GetBattlegroundTypeId());
+        // remember current position as entry point for return at bg end teleportation
+        if (!player->GetMap()->IsBattlegroundOrArena())
+            player->SetBattlegroundEntryPoint();
+
+        if (target->isSpectator())
+        {
+            handler->PSendSysMessage("Your target is spectator.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        // stop flight if need
+        if (player->IsInFlight())
+        {
+            player->GetMotionMaster()->MovementExpired();
+            player->CleanupAfterTaxiFlight();
+        }
+        else // save only in non-flight case
+            player->SaveRecallPosition();
+
+        // search for two teams
+        Battleground *bGround = target->GetBattleground();
+        if (bGround->isRated())
+        {
+            const uint8 slot = (bGround->GetArenaType() > 3) ? 2 : bGround->GetArenaType() - 2;
+            uint32 firstTeamID = target->GetArenaTeamId(slot);
+            uint32 secondTeamID = 0;
+            Player *firstTeamMember = target;
+            Player *secondTeamMember = NULL;
+            for (Battleground::BattlegroundPlayerMap::const_iterator itr = bGround->GetPlayers().begin(); itr != bGround->GetPlayers().end(); ++itr)
+            {
+                if (Player* tmpPlayer = ObjectAccessor::FindPlayer(itr->first))
+                {
+                    if (tmpPlayer->isSpectator())
+                        continue;
+
+                    uint32 tmpID = tmpPlayer->GetArenaTeamId(slot);
+                    if (tmpID != firstTeamID && tmpID > 0)
+                    {
+                        secondTeamID = tmpID;
+                        secondTeamMember = tmpPlayer;
+                        break;
+                    }
+                }
+            }
+            if (firstTeamID > 0 && secondTeamID > 0 && secondTeamMember)
+            {
+                ArenaTeam *firstTeam = sArenaTeamMgr->GetArenaTeamById(firstTeamID);
+                ArenaTeam *secondTeam = sArenaTeamMgr->GetArenaTeamById(secondTeamID);
+                if (firstTeam && secondTeam)
+                {
+                    handler->PSendSysMessage("You entered to rated arena.");
+                    handler->PSendSysMessage("Teams:");
+                    handler->PSendSysMessage("%s - %s", firstTeam->GetName().c_str(), secondTeam->GetName().c_str());
+                    handler->PSendSysMessage("%u(%u) - %u(%u)", firstTeam->GetRating(), firstTeam->GetAverageMMR(firstTeamMember->GetGroup()),
+                        secondTeam->GetRating(), secondTeam->GetAverageMMR(secondTeamMember->GetGroup()));
+                }
+            }
+        }
+
+        // to point to see at target with same orientation
+        float x, y, z;
+        target->GetContactPoint(player, x, y, z);
+
+        player->TeleportTo(target->GetMapId(), x, y, z, player->GetAngle(target), TELE_TO_GM_MODE);
+        player->SetPhaseMask(target->GetPhaseMask(), true);
+        player->SetSpectate(true);
+        target->GetBattleground()->AddSpectator(player->GetGUID());
+
+        return true;
+    }
+
+    static bool HandleSpectateCancelCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+
+        if (!player->isSpectator())
+        {
+            handler->PSendSysMessage("You are not a spectator.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        player->GetBattleground()->RemoveSpectator(player->GetGUID());
+        player->CancelSpectate();
+        player->TeleportToBGEntryPoint();
+
+        return true;
+    }
+
+    static bool HandleSpectateFromCommand(ChatHandler* handler, const char *args)
+    {
+        Player* target;
+        ObjectGuid target_guid;
+        std::string target_name;
+        if (!handler->extractPlayerTarget((char*)args, &target, &target_guid, &target_name))
+            return false;
+
+        Player* player = handler->GetSession()->GetPlayer();
+
+        if (!target)
+        {
+            handler->PSendSysMessage("Can't find the player.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!player->isSpectator())
+        {
+            handler->PSendSysMessage("You are not spectator, spectate someone first.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (target->isSpectator() && target != player)
+        {
+            handler->PSendSysMessage("Can't do that. Your target is spectator.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (player->GetMap() != target->GetMap())
+        {
+            handler->PSendSysMessage("Can't do that. Different arenas?");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        // check for arena preparation
+        // if exists than battle didn`t begin
+        if (target->HasAura(32728) || target->HasAura(32727))
+        {
+            handler->PSendSysMessage("Can't do that. Arena didn't started.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (target == player && player->getSpectateFrom())
+            player->SetViewpoint(player->getSpectateFrom(), false);
+        else
+            player->SetViewpoint(target, true);
+        return true;
+    }
+
+    static bool HandleSpectateResetCommand(ChatHandler* handler, const char * /*args*/)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+
+        if (!player)
+        {
+            handler->PSendSysMessage("Cant find player.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!player->isSpectator())
+        {
+            handler->PSendSysMessage("You are not spectator!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Battleground *bGround = player->GetBattleground();
+        if (!bGround)
+            return false;
+
+        if (bGround->GetStatus() != STATUS_IN_PROGRESS)
+            return true;
+
+        for (Battleground::BattlegroundPlayerMap::const_iterator itr = bGround->GetPlayers().begin(); itr != bGround->GetPlayers().end(); ++itr)
+        {
+            if (Player* tmpPlayer = ObjectAccessor::FindPlayer(itr->first))
+            {
+                if (tmpPlayer->isSpectator())
+                    continue;
+
+                uint32 tmpID = bGround->GetPlayerTeam(tmpPlayer->GetGUID());
+
+                // generate addon message
+                std::string pName = tmpPlayer->GetName();
+                std::string tName = "";
+
+                if (Player *target = tmpPlayer->GetSelectedPlayer())
+                    tName = target->GetName();
+
+                SpectatorAddonMsg msg;
+                msg.SetPlayer(pName);
+                if (tName != "")
+                    msg.SetTarget(tName);
+                msg.SetStatus(tmpPlayer->IsAlive());
+                msg.SetClass(tmpPlayer->getClass());
+                msg.SetCurrentHP(tmpPlayer->GetHealth());
+                msg.SetMaxHP(tmpPlayer->GetMaxHealth());
+                const Powers powerType = tmpPlayer->getPowerType();
+                msg.SetMaxPower(tmpPlayer->GetMaxPower(powerType));
+                msg.SetCurrentPower(tmpPlayer->GetPower(powerType));
+                msg.SetPowerType(powerType);
+                msg.SetTeam(tmpID);
+                msg.SendPacket(player->GetGUID());
+            }
+        }
+        return true;
+    }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand spectateCommandTable[] =
+        {
+            { "player", rbac::RBAC_PERM_COMMAND_SPECATE_VIEW, true, &HandleSpectateCommand, "", NULL },
+            { "view", rbac::RBAC_PERM_COMMAND_SPECATE_RESET, true, &HandleSpectateFromCommand, "", NULL },
+            { "reset", rbac::RBAC_PERM_COMMAND_SPECATE_LEAVE, true, &HandleSpectateResetCommand, "", NULL },
+            { "leave", rbac::RBAC_PERM_COMMAND_SPECATE_PLAYER, true, &HandleSpectateCancelCommand, "", NULL },
+            { NULL, 0, false, NULL, "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "spectate", rbac::RBAC_PERM_COMMAND_SPECATE, false, NULL, "", spectateCommandTable },
+            { NULL, 0, false, NULL, "", NULL }
+        };
+        return commandTable;
+    }
+};
+
+class npc_arena_spectator : public CreatureScript
+{
+public:
+    npc_arena_spectator() : CreatureScript("npc_arena_spectator") { }
+
+    bool OnGossipHello(Player* player, Creature* me)
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Ladder Menu :", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SHOW_MENU);
+        GetTopMenuByType(player, ARENA_TEAM_2v2);
+        GetTopMenuByType(player, ARENA_TEAM_3v3);
+        GetTopMenuByType(player, ARENA_TEAM_5v5);
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Spectate Menu :", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SHOW_MENU);
+        GetSpecateMenuByType(player, ARENA_TEAM_2v2);
+        GetSpecateMenuByType(player, ARENA_TEAM_3v3);
+        GetSpecateMenuByType(player, ARENA_TEAM_5v5);
+
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, me->GetGUID());
+        return true;
+    }
+
+    void GetTopMenuByType(Player* player, const uint8 type)
+    {
+        std::stringstream ss;
+        ss << "|TInterface\\icons\\Achievement_Arena_" << (int)type << 'v' << (int)type << "_6:42|t Show the " << (int)type << 'v' << (int)type << " Top teams list";
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, ss.str(), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_TOP + type);
+    }
+
+    void GetSpecateMenuByType(Player* player, const uint8 type)
+    {
+        std::stringstream ss;
+        uint32 action;
+        ss << "|TInterface\\icons\\Achievement_Arena_" << (int)type << 'v' << (int)type << '_';
+        const uint16 count = ListActiveArena(player, 0, true, type);
+        if (count == 1)
+        {
+            ss << "7:42|t Only one game avaible in " << (int)type << 'v' << (int)type;
+            action = GOSSIP_ACTION_SHOW_GAMES + type;
+        }
+        else if (count)
+        {
+            ss << "7:42|t Browse the " << (int)count << " games of " << (int)type << 'v' << (int)type;
+            action = GOSSIP_ACTION_SHOW_GAMES + type;
+        }
+        else
+        {
+            ss << urand(1, 4) << ":42|t " << (int)type << 'v' << (int)type << " : No games, click to refresh.";
+            action = GOSSIP_ACTION_SHOW_MENU;
+        }
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, ss.str(), GOSSIP_SENDER_MAIN, action);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* me, uint32 data, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        if (action >= GOSSIP_ACTION_SPECTATE)
+        {
+            if (Player* target = ObjectAccessor::FindPlayer(ObjectGuid(HIGHGUID_PLAYER, action - GOSSIP_ACTION_SPECTATE)))
+            {
+                ChatHandler handler(player->GetSession());
+                char const* pTarget = target->GetName().c_str();
+                m_usingGossip = true;
+                arena_spectator_commands::HandleSpectateCommand(&handler, pTarget);
+                return true;
+            }
+        }
+        else if (action >= GOSSIP_ACTION_DETAIL_ON_TEAM)
+            ShowTeamInfo(player, data, action - GOSSIP_ACTION_DETAIL_ON_TEAM);
+        else if (action >= GOSSIP_ACTION_TOP)
+            ListTopArena(player, action - GOSSIP_ACTION_TOP);
+        else if (action >= GOSSIP_ACTION_SHOW_GAMES)
+            ListActiveArena(player, 0, false, action - GOSSIP_ACTION_SHOW_GAMES);
+        else if (action >= GOSSIP_ACTION_SHOW_GAMES_PAGE) // data is for the page here
+            ListActiveArena(player, data, false, action - GOSSIP_ACTION_SHOW_GAMES_PAGE);
+        else
+        {
+            OnGossipHello(player, me);
+            return true;
+        }
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, me->GetGUID());
+        return true;
+    }
+
+    std::string GetClassColorById(uint8 id)
+    {
+        std::string sClass = "";
+        switch (id)
+        {
+            case CLASS_WARRIOR:
+                sClass = "|cffC79C6E";
+                break;
+            case CLASS_PALADIN:
+                sClass = "|cffF58CBA";
+                break;
+            case CLASS_HUNTER:
+                sClass = "|cffABD473";
+                break;
+            case CLASS_ROGUE:
+                sClass = "|cffFFF569";
+                break;
+            case CLASS_PRIEST:
+                sClass = "|cffFFFFFF";
+                break;
+            case CLASS_DEATH_KNIGHT:
+                sClass = "|cffC41F3B";
+                break;
+            case CLASS_SHAMAN:
+                sClass = "|cff0070DE";
+                break;
+            case CLASS_MAGE:
+                sClass = "|cff69CCF0";
+                break;
+            case CLASS_WARLOCK:
+                sClass = "|cff9482C9";
+                break;
+            case CLASS_DRUID:
+                sClass = "|cffFF7D0A";
+                break;
+        }
+        return sClass;
+    }
+
+    //Interface\BUTTONS\UI-GroupLoot-Dice-Up.blp //Interface\BUTTONS\UI-GroupLoot-Dice-Up.blp
+    std::string GetRankIcon(const int32 rating)
+    {
+        if (rating < 0) // skirmish
+            return (std::string("|TInterface\\BUTTONS\\UI-GroupLoot-Dice-Up:26|t"));
+
+        uint8 iconID = 1;
+        for (uint16 min = 1000; iconID < 15 && rating > min; min += 100)
+            iconID++;
+
+        std::stringstream ss;
+        ss << "|TInterface\\PvPRankBadges\\PvPRank";
+        if (iconID < 10)
+            ss << '0';
+        ss << (int)iconID << ":26|t";
+        return ss.str();
+    }
+
+    std::string GetClassIconById(uint8 id)
+    {
+        std::string sClass = "";
+        switch (id)
+        {
+            case CLASS_WARRIOR:
+                sClass = "|TInterface\\icons\\Inv_sword_27:26|t";
+                break;
+            case CLASS_PALADIN:
+                sClass = "|TInterface\\icons\\Ability_thunderbolt:26|t";
+                break;
+            case CLASS_HUNTER:
+                sClass = "|TInterface\\icons\\Inv_weapon_bow_07:26|t";
+                break;
+            case CLASS_ROGUE:
+                sClass = "|TInterface\\icons\\Inv_throwingknife_04:26|t";
+                break;
+            case CLASS_PRIEST:
+                sClass = "|TInterface\\icons\\Inv_staff_30:26|t";
+                break;
+            case CLASS_DEATH_KNIGHT:
+                sClass = "|TInterface\\CharacterFrame\\Button_ClassIcon_DeathKnight:26|t";
+                break;
+            case CLASS_SHAMAN:
+                sClass = "|TInterface\\icons\\Spell_nature_bloodlust:26|t";
+                break;
+            case CLASS_MAGE:
+                sClass = "|TInterface\\icons\\Inv_staff_13:26|t";
+                break;
+            case CLASS_WARLOCK:
+                sClass = "|TInterface\\icons\\Spell_nature_drowsy:26|t";
+                break;
+            case CLASS_DRUID:
+                sClass = "|TInterface\\icons\\inv_misc_monsterclaw_04:26|t";
+                break;
+        }
+        return sClass;
+    }
+
+    inline bool IsValidArenaType(uint8 type)
+    {
+        switch (type)
+        {
+            case ARENA_TEAM_2v2:
+            case ARENA_TEAM_3v3:
+            case ARENA_TEAM_5v5:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    void ShowTeamInfo(Player* player, uint32 teamId, uint8 type)
+    {
+        const uint32 action = IsValidArenaType(type) ? GOSSIP_ACTION_TOP + type : GOSSIP_ACTION_SHOW_MENU;
+        ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(teamId);
+        if (!at)
+        {
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Team not found, click to return.", GOSSIP_SENDER_MAIN, action);
+            return;
+        }
+        std::
+            stringstream ss;
+        const ArenaTeamStats stats = at->GetStats();
+        // build team info msg
+        ss << "Rank: " << stats.Rank << " - " << at->GetName() << '\n';
+        ss << "Rating: " << stats.Rating << '\n';
+        //        ss << "Average MMR: " << at->GetAverageMMR() << '\n';
+        ss << "Week Games: " << stats.WeekGames << '\n';
+        ss << "Week Wins: " << stats.WeekWins << '\n';
+
+        ss << "Season Games: " << stats.SeasonGames << '\n';
+        ss << "Season Wins: " << stats.SeasonWins << '\n';
+        // send gossip
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, ss.str(), GOSSIP_SENDER_MAIN, action);
+
+        for (ArenaTeam::MemberList::iterator itr = at->m_membersBegin(); itr != at->m_membersEnd(); ++itr)
+        {
+            ss.str(std::string());
+            ss << GetClassIconById(itr->Class) << ' ' << itr->Name << " (" << itr->PersonalRating << "), MMR: " << itr->MatchMakerRating;
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, ss.str(), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SPECTATE + itr->Guid.GetCounter());
+        }
+        if (at->IsFighting())
+        {
+            for (ArenaTeam::MemberList::iterator itr = at->m_membersBegin(); itr != at->m_membersEnd(); ++itr)
+            {
+                if (Player* member = ObjectAccessor::FindPlayer(itr->Guid))
+                {
+                    if (!member->isSpectator() && member->InArena())
+                    {
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Team is playing, spectate now !", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SPECTATE + itr->Guid.GetCounter());
+                        break;
+                    }
+                }
+            }
+        }
+
+        //GetChanceAgainst()
+    }
+
+    std::string GetGamesStringData(Battleground* arena)
+    {
+        std::stringstream ss;
+        for (Battleground::BattlegroundPlayerMap::const_iterator itr = arena->GetPlayers().begin(); itr != arena->GetPlayers().end(); ++itr)
+        {
+            if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+            {
+                if (player->isSpectator())
+                    continue;
+                ss << GetClassIconById(player->getClass());
+            }
+        }
+        return ss.str();
+    }
+
+    std::string GetGameIcons(Battleground* arena)
+    {
+        std::string teamsMember[BG_TEAMS_COUNT];
+        for (Battleground::BattlegroundPlayerMap::const_iterator itr = arena->GetPlayers().begin(); itr != arena->GetPlayers().end(); ++itr)
+        {
+            if (Player* player = ObjectAccessor::FindPlayer(itr->first))
+            {
+                if (!player->isSpectator())
+                    teamsMember[player->GetTeamId()] += GetClassIconById(player->getClass());
+            }
+        }
+        if (arena->isRated())
+            return GetRankIcon(arena->GetArenaMatchmakerRating(ALLIANCE)) + teamsMember[0] + "  |TInterface\\RAIDFRAME\\UI-RaidFrame-Threat:26|t  " + teamsMember[1] + GetRankIcon(arena->GetArenaMatchmakerRating(HORDE));
+        return GetRankIcon(-1) + teamsMember[0] + "  |TInterface\\RAIDFRAME\\UI-RaidFrame-Threat:26|t  " + teamsMember[1] + GetRankIcon(-1);
+    }
+
+    uint64 GetFirstPlayerGuid(Battleground* arena)
+    {
+        for (Battleground::BattlegroundPlayerMap::const_iterator itr = arena->GetPlayers().begin(); itr != arena->GetPlayers().end(); ++itr)
+        {
+            if (ObjectAccessor::FindPlayer(itr->first))
+                return itr->first;
+        }
+        return 0;
+    }
+
+    uint16 ListActiveArena(Player* player, uint16 page, bool ammountOnly, const uint8 type)
+    {
+        uint16 elemCount = 0;
+        bool haveNextPage = false;
+        if (!ammountOnly)
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "<- return to menu", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SHOW_MENU);
+        for (uint8 i = 0; i <= MAX_BATTLEGROUND_TYPE_ID; ++i)
+        {
+            if (!sBattlegroundMgr->IsArenaType(BattlegroundTypeId(i)))
+                continue;
+
+            const BattlegroundContainer arenas = sBattlegroundMgr->GetBattlegroundsByType(BattlegroundTypeId(i));
+
+            if (arenas.empty())
+                continue;
+
+            for (BattlegroundContainer::const_iterator itr = arenas.begin(); itr != arenas.end(); ++itr)
+            {
+                Battleground* arena = itr->second;
+
+                if (!arena->GetPlayersSize())
+                    continue;
+
+                if (type != arena->GetArenaType())
+                    continue;
+
+                elemCount++;
+
+                if (ammountOnly)
+                    continue;
+
+                if (elemCount > (page + 1) * MAX_PER_PAGE)
+                {
+                    haveNextPage = true;
+                    break;
+                }
+                //std::stringstream ss;
+
+                //if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(bg->GetArenaTeamIdByIndex(type)))
+                //    ss << at->GetName();
+
+                if (!page || elemCount >= page * MAX_PER_PAGE)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, GetGameIcons(arena), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SPECTATE + GetFirstPlayerGuid(arena));
+            }
+        }
+
+        if (!ammountOnly)
+        {
+            if (page > 0)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Prev..", page - 1, GOSSIP_ACTION_SHOW_GAMES_PAGE + type);
+
+            if (haveNextPage)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Next..", page + 1, GOSSIP_ACTION_SHOW_GAMES_PAGE + type);
+        }
+        return elemCount;
+    }
+
+    void ListTopArena(Player* player, const uint8 type)
+    {
+        // first give a return option
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "<- return to menu", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SHOW_MENU);
+
+        uint8 rank = 0;
+        while (rank < MAX_TOP)
+        {
+            std::stringstream ss;
+            const uint32 teamId = sBattlegroundMgr->GetTopArenaTeamByRank(type, rank);
+            rank++;
+            if (!teamId)
+            {
+                if (!rank)
+                {
+                    player->GetSession()->SendNotification("Arena teams not found...");
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, "Arena teams not found...", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SHOW_MENU);
+                }
+                else
+                {
+                    ss << "Only " << (int)rank << " team";
+                    if (rank > 1)
+                        ss << 's';
+                    ss << " found.";
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, ss.str(), GOSSIP_SENDER_MAIN, GOSSIP_ACTION_SHOW_MENU);
+                }
+                return;
+            }
+
+            ss << "|TInterface\\PvPRankBadges\\PvPRank";
+            if (rank > 5)
+                ss << '0';
+            ss << MAX_TOP - (rank - 1) << ":18|t ";
+            if (ArenaTeam* at = sArenaTeamMgr->GetArenaTeamById(teamId))
+            {
+                size_t crop = 27;
+                if (at->IsFighting())
+                {
+                    ss << "(Fighting) ";
+                    crop = 18;
+                }
+                std::string name = at->GetName();
+                if (name.length() < crop + 1)
+                    ss << at->GetRating() << " - " << name;
+                else
+                {
+                    name.erase(crop, std::string::npos);
+                    ss << at->GetRating() << " - " << name << "...";
+                }
+            }
+            else
+                ss << "couldn't get arena team stats.";
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_DOT, ss.str(), teamId, GOSSIP_ACTION_DETAIL_ON_TEAM + type);
+        }
+    }
+
+};
+
+void AddSC_arena_spectator_script()
+{
+    new arena_spectator_commands();
+    new npc_arena_spectator();
+}
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 5218f76..02714ef 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -13,6 +13,7 @@
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
 #  ${sources_Custom}
+  Custom/ArenaSpectator.cpp
 )
 
 message("  -> Prepared: Custom")